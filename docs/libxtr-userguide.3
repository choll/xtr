.\" Man page generated from reStructuredText.
.
.TH "LIBXTR-USERGUIDE" "3" "August 2021" "" "xtr"
.SH NAME
libxtr-userguide \- C++ logging library user guide
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH OVERVIEW
.sp
The XTR API contains two classes; \fBxtr::logger\fP and
\fBxtr::sink\fP\&. Sinks each contain a queue [1], and
pass log messages to the associated logger via these queues. Each logger
has a background consumer thread which reads from the sinks that were created from the
logger. The background thread then formats the log message and either writes it
to disk or passes it to a custom back\-end if one is in use.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
+\-\-\-\-\-\-+
| Sink |\-\-\-[queue]\-\-\-+
+\-\-\-\-\-\-+             |
                     |     +\-\-\-\-\-\-\-\-+
+\-\-\-\-\-\-+             +\-\-\-> |        |     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
| Sink |\-\-\-[queue]\-\-\-\-\-\-\-> | Logger |\-\-\-> | Back\-end; file/network/etc |
+\-\-\-\-\-\-+             +\-\-\-> |        |     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
                     |     +\-\-\-\-\-\-\-\-+
+\-\-\-\-\-\-+             |
| Sink |\-\-\-[queue]\-\-\-+
+\-\-\-\-\-\-+
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
An application is expected to use multiple sinks, for example a sink per thread, or
sink per component. To support this sinks have a name associated with them which
is included in the output log message. Sink names do not need to be unique.
.SH CREATING AND WRITING TO SINKS
.sp
Sinks are created by calling \fBxtr::logger::get_sink()\fP or via normal
construction followed by a call to \fBxtr::logger::register_sink()\fP\&.
Once a sink has been created or registered, it may be written to using one of several
log macros which are described in the log macros section.
.SS Examples
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <xtr/logger.hpp>

xtr::logger log;

xtr::sink s = log.get_sink("Main");

XTR_LOG(s, "Hello world");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/1GWbEPq8T\fP>\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <xtr/logger.hpp>

xtr::logger log;
xtr::sink s;

log.register_sink(s, "Main");

XTR_LOG(s, "Hello world");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/cobj4n3Gx\fP>\&.
.SH FORMAT STRING SYNTAX
.sp
XTR uses \fI\%{fmt}\fP <\fBhttps://fmt.dev\fP> for formatting, so format strings follow the
same Python \fI\%str.format\fP <\fBhttps://docs.python.org/3/library/string.html#formatstrings\fP>
style formatting as found in {fmt}. The {fmt} format string documentation can be found
\fI\%here\fP <\fBhttps://fmt.dev/latest/syntax.html\fP>\&.
.SS Examples
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
xtr::logger log;

xtr::sink s = log.get_sink("Main");

XTR_LOG(s, "Hello {}", 123); // Hello 123
XTR_LOG(s, "Hello {}", 123.456); // Hello 123.456
XTR_LOG(s, "Hello {:.1f}", 123.456); // Hello 123.1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/zxs7WThM6\fP>\&.
.SH PASSING ARGUMENTS BY VALUE OR REFERENCE
.sp
The default behaviour of the logger is to copy format arguments into the
specified sink by value. Note that no allocations are be performed by the
logger when this is done. If copying is undesirable then arguments may be
passed by reference by wrapping them in a call to \fBxtr::nocopy()\fP\&.
.SS Examples
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
xtr::logger log;

xtr::sink s = log.get_sink("Main");

static std::string arg = "world";

// Here \(aqarg\(aq is passed by reference:
XTR_LOG(s, "Hello {}", nocopy(arg));

// Here \(aqarg\(aq is passed by value:
XTR_LOG(s, "Hello {}", arg);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/j5ebhWfdT\fP>\&.
.SH STRING ARGUMENTS
.sp
Passing strings to the logger is guaranteed to not allocate memory, and does
not assume anything about the lifetime of the string data. i.e. for the
following log statement:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
XTR_LOG(s, "{}", str);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If \fIstr\fP is a std::string, std::string_view,
char* or char[] then the contents of \fIstr\fP will be copied
into \fIsink\fP without incurring any allocations. The entire statement is guaranteed
to not allocate\-\-\-i.e. even if std::string is passed, the
std::string copy constructor is not invoked and no allocation occurs.
String data is copied in order to provide safe default behaviour regarding the
lifetime of the string data. If copying the string data is undesirable then
string arguments may be wrapped in a call to \fBxtr::nocopy()\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
XTR_LOG(sink, "{}", nocopy(str));
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If this is done then only a pointer to the string data contained in \fIstr\fP is
copied. The user is then responsible for ensuring that the string data remains
valid long enough for the logger to process the log statement. Note that only
the string data must remain valid\-\-\-so for std::string_view the
object itself does not need to remain valid, just the data it references.
.SH LOG LEVELS
.sp
The logger supports debug, info, warning, error and fatal log levels.
Log statements with these levels may be produced using the
\fBXTR_LOG_DEBUG\fP, \fBXTR_LOG_INFO\fP, \fBXTR_LOG_WARN\fP
\fBXTR_LOG_ERROR\fP and \fBXTR_LOG_FATAL\fP macros, along with
additional macros which are described in the log macros
section of the API reference.
.sp
Each sink has its own log level, which can be programmatically set or queried
via \fBxtr::sink::set_level()\fP and \fBxtr::sink::level()\fP, and can
be set or queried from the command line using the xtrctl tool.
.sp
Each log level has an order of importance. The listing of levels above is in
the order of increasing importance\-\-\-so the least important level is \(aqdebug\(aq
and the most important level is \(aqfatal\(aq. If a log statement is made with a
level that is lower than the current level of the sink then the log statement
is discarded. Note that this includes any calls made as arguments to the log,
so in the following example the function \fBfoo()\fP is not called:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <xtr/logger.hpp>

xtr::logger log;

xtr::sink s = log.get_sink("Main");

s.set_level(xtr::log_level_t::error);

XTR_LOG_INFO(s, "Hello {}", foo());
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/G4P4zfP6r\fP>\&.
.SS Debug Log Statements
.sp
Debug log statements can be disabled by defining XTR_NDEBUG.
.SS Fatal Log Statements
.sp
Fatal log statements will additionally call \fBxtr::sink::sync()\fP followed
by \fI\%abort(3)\fP <\fBhttps://www.man7.org/linux/man-pages/man3/abort.3.html\fP>\&.
.SS Setting the default log level
.sp
TODO
.SH THREAD SAFETY
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
All functions in \fBxtr::logger\fP are thread\-safe.
.IP \(bu 2
No functions in \fBxtr::sink\fP are thread\-safe other than
\fBxtr::sink::level()\fP and \fBxtr::sink::set_level()\fP\&.
This is because each thread is expected to have its own sink(s).
.UNINDENT
.UNINDENT
.UNINDENT
.SH CUSTOM FORMATTERS
.sp
Custom formatters are implemented the same as in \fI\%{fmt}\fP <\fBhttps://fmt.dev\fP>,
which is done either by:
.INDENT 0.0
.IP \(bu 2
Providing a \fBstd::stream& operator<<(std::stream&, T&)()\fP overload. Note
that fmt/ostream.h must be included.
.IP \(bu 2
Specializing fmt::formatter<T> and implementing the \fIparse\fP and
\fIformat\fP methods as described by the \fI{fmt}\fP documentation
\fI\%here\fP <\fBhttps://fmt.dev/latest/api.html#formatting-user-defined-types\fP>\&.
.UNINDENT
.SS Examples
.sp
Formatting a custom type via operator<<:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <fmt/ostream.h>

#include <ostream>

namespace
{
    struct custom {};

    std::ostream& operator<<(std::ostream& os, const custom&)
    {
        return os << "custom";
    }
}

int main()
{
    xtr::logger log;

    xtr::sink s = log.get_sink("Main");

    XTR_LOG(s, "Hello {}", custom());

    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/cK14z5Kr6\fP>\&.
.sp
Formatting a custom type via fmt::formatter:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
namespace
{
    struct custom {};
}

template<>
struct fmt::formatter<custom>
{
    template<typename ParseContext>
    constexpr auto parse(ParseContext &ctx)
    {
        return ctx.begin();
    }

    template<typename FormatContext>
    auto format(const custom &, FormatContext &ctx)
    {
        return format_to(ctx.out(), "custom");
    }
};

int main()
{
    xtr::logger log;

    xtr::sink s = log.get_sink("Main");

    XTR_LOG(s, "Hello {}", custom());

    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
View this example on \fI\%Compiler Explorer\fP <\fBhttps://godbolt.org/z/h5vsv354E\fP>\&.
.SH TIME SOURCES
.sp
XTR supports multiple time\-sources when logging messages, with varying levels of
accuracy and performance.
.INDENT 0.0
.IP \(bu 2
Asynchronous\-default: The default time\-source is to read \fIstd::chrono::system_clock\fP
\fIin the logger background thread\fP\&. This is to avoid the expense of reading the clock
at the logging call\-site. The trade\-off is that this comes with a loss of accuracy
due to the time the log message spends on the queue.
.IP \(bu 2
Asynchronous\-custom
.IP \(bu 2
Synchronous\-TSC
.IP \(bu 2
Synchronous\-Coarse
.IP \(bu 2
Synchronous\-Custom
.UNINDENT
.SS Basic with Default Clock
.sp
For :cpp:def
.sp
See the basic log macros section of the API reference for
details.
.SS Basic with Custom Clock
.SS TSC
.sp
TSC Calibration
.SS Real\-time Clock
.sp
XTR_LOG_RTC, XTR_TRY_LOG_RTC
.SS User\-Supplied Timestamp
.sp
XTR_LOG_TS,  XTR_TRY_LOG_TS
.SH CUSTOMISING THE TIME FORMAT
.SH BACKGROUND CONSUMER THREAD DETAILS
.sp
As no system calls are made when a log statement is made, the consumer
thread must spin waiting for input (it cannot block/wait as there would
be no way to signal that doesn\(aqt involve a system call). This is simply
done as a performance/efficiency trade\-off; log statements become cheaper
at the cost of the consumer thread being wasteful.
.SS Lifetime
.sp
The consumer thread associated with a given logger will terminate only
when the logger and all associated sinks have been destructed, and is
joined by the logger destructor. This means that when the logger
destructs, it will block until all associated sinks have also destructed.
.sp
This is done to make using the logger easier\-\-\-sinks will never lose data
and will never be disconnected from the associated logger unless they are
explicitly disconnected by closing the sink.
.SS CPU Affinity
.sp
To bind the background thread to a specific CPU
\fBxtr::logger::consumer_thread_native_handle()\fP can be used to obtain
the consumer thread\(aqs platform specific thread handle. The handle can then be
used with whatever platform specific functionality is available for setting
thread affinities\-\-\-for example
\fI\%pthread_setaffinity_np(3)\fP <\fBhttps://www.man7.org/linux/man-pages/man3/pthread_setaffinity_np.3.html\fP>
on Linux.
.SH LOG MESSAGE SANITIZING
.sp
STRINGS ARE SANITIZED, PROVIDE CUSTOM FORMATTER TO WRITE BINARY DATA
.sp
Strings containing unprintable characters are sanitized
.SH CUSTOM BACK-ENDS
.SH FOOTNOTES
.IP [1] 5
Specifically the queue is a single\-producer/single\-consumer ring buffer.
.SH AUTHOR
Chris E. Holloway
.SH COPYRIGHT
2021, Chris E. Holloway
.\" Generated by docutils manpage writer.
.
