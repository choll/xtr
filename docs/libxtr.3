.\" Man page generated from reStructuredText.
.
.TH "LIBXTR" "3" "August 2021" "" "xtr"
.SH NAME
libxtr \- C++ logging library API reference
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH LOG MACROS
.SS Basic Macros
.INDENT 0.0
.TP
.B XTR_LOG(SINK, \&...) 
Basic log macro, logs the specified format string and arguments to the given sink, blocking if the sink is full. The non\-blocking variant of this macro is XTR_TRY_LOG which will discard the message if the sink is full. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_DEBUG(SINK, \&...) 
\(aqDebug\(aq log level variant of XTR_LOG An equivalent macro XTR_LOGD is provided as a short\-hand alternative. This macro can be disabled at build time by defining XTR_NDEBUG. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_INFO(SINK, \&...) 
\(aqInfo\(aq log level variant of XTR_LOG An equivalent macro XTR_LOGI is provided as a short\-hand alternative. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_WARN(SINK, \&...) 
\(aqWarning\(aq log level variant of XTR_LOG An equivalent macro XTR_LOGW is provided as a short\-hand alternative. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_ERROR(SINK, \&...) 
\(aqError\(aq log level variant of XTR_LOG An equivalent macro XTR_LOGE is provided as a short\-hand alternative. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_FATAL(SINK, \&...) 
\(aqFatal\(aq log level variant of XTR_LOG. An equivalent macro XTR_LOGF is provided as a short\-hand alternative. When this macro is invoked, the log message is written, \fI\%xtr::logger::sink::sync\fP is invoked, then the program is terminated via abort(3). 
.UNINDENT
.SS Timestamped Macros
.SS TSC
.INDENT 0.0
.TP
.B XTR_LOG_TSC(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TSC_DEBUG(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TSC_INFO(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TSC_WARN(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TSC_ERROR(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TSC_FATAL(SINK, \&...) 
.UNINDENT
.SS Real\-time Clock
.INDENT 0.0
.TP
.B XTR_LOG_RTC(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_RTC_DEBUG(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_RTC_INFO(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_RTC_WARN(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_RTC_ERROR(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_RTC_FATAL(SINK, \&...) 
.UNINDENT
.SS User\-Supplied Timestamp
.INDENT 0.0
.TP
.B XTR_LOG_TS(SINK, TS, \&...) 
Timestamped log macro, logs the specified format string and arguments to the given sink along with the specified timestamp, blocking if the sink is full. The timestamp may be any type so long as it has a formatter defined (see :ref:custom\-formatters). xtr::timestamp is provided as a convenience type which is compatible with std::timestamp and has a formatter pre\-defined. A formatter for std::timestamp isn\(aqt defined in order to avoid conflict with user code that also defines such a formatter. 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TS_DEBUG(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TS_INFO(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TS_WARN(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TS_ERROR(SINK, \&...) 
.UNINDENT
.INDENT 0.0
.TP
.B XTR_LOG_TS_FATAL(SINK, \&...) 
\(aqFatal\(aq log level variant of XTR_LOG_TS. An equivalent macro XTR_LOG_TSF is provided as a short\-hand alternative. 
.UNINDENT
.SH LOGGER
.INDENT 0.0
.TP
.B class  logger 
The main logger class. When constructed a background thread will be created which is used for formatting log messages and performing I/O. To write to the logger call \fI\%logger::sink\fP then pass the sink to a macro such as XTR_LOG. 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Clock  =  std::chrono::system_clock> inline  xtr::\fI\%logger\fP::logger(const  char  *path, \fI\%Clock\fP  &&clock  =  \fI\%Clock\fP(), std::string  command_path  =  default_command_path()) 
TODO 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Clock  =  std::chrono::system_clock> inline  xtr::\fI\%logger\fP::logger(const  char  *path, FILE  *stream, FILE  *err_stream  =  stderr, \fI\%Clock\fP  &&clock  =  \fI\%Clock\fP(), std::string  command_path  =  default_command_path()) 
TODO 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Clock  =  std::chrono::system_clock> inline  xtr::\fI\%logger\fP::logger(FILE  *stream  =  stderr, FILE  *err_stream  =  stderr, \fI\%Clock\fP  &&clock  =  \fI\%Clock\fP(), std::string  command_path  =  default_command_path()) 
TODO 
.UNINDENT
.INDENT 0.0
.TP
.B xtr::\fI\%logger\fP::~logger() 
Logger destructor. This function will join the consumer thread. If sinks are still connected to the logger then the consumer thread will not terminate until the sinks disconnect, i.e. the destructor will block until all connected sinks disconnect from the logger. 
.UNINDENT
.INDENT 0.0
.TP
.B \fI\%sink\fP  xtr::\fI\%logger\fP::get_sink(std::string  name) 
Creates a sink with the specified name. Note that each call to this function creates a new sink; if repeated calls are made with the same name, separate sinks with the name name are created.
.INDENT 7.0
.TP
.B Parameters
\fBname\fP \-\- The name for the given sink. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::register_sink(\fI\%sink\fP  &s, std::string  name)  noexcept 
Registers the sink with the logger. Note that the sink name does not need to be unique; if repeated calls are made with the same name, separate sinks with the same name are registered.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBs\fP \-\- The sink to register. 
.IP \(bu 2
\fBname\fP \-\- The name for the given sink.
.UNINDENT
.TP
.B Pre
The sink must be closed. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B inline  std::thread::native_handle_type  xtr::\fI\%logger\fP::consumer_thread_native_handle() 
Returns the native handle for the logger\(aqs consumer thread. This may be used for setting thread affinities or other thread attributes. 
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::set_output_stream(FILE  *stream)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::set_error_stream(FILE  *stream)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_output_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_error_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_flush_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_sync_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_reopen_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B template<typename  Func> inline  void  xtr::\fI\%logger\fP::set_close_function(\fI\%Func\fP  &&f)  noexcept 
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::set_command_path(std::string  path)  noexcept 
.UNINDENT
.SH SINK
.INDENT 0.0
.TP
.B class  sink 
Log sink class. A sink is how log messages are written to a log. Each sink has its own queue which is used to send log messages to the logger. Sink operations are not thread safe, with the exception of \fI\%set_level\fP and \fI\%level\fP\&.
.sp
It is expected that an application will have many sinks, such as a sink per thread or sink per component. A sink that is connected to a logger may be created by calling \fI\%get_sink\fP\&. A sink that is not connected to a logger may be created simply by default construction, then the sink may be connected to a logger by calling \fI\%register_sink\fP\&. 
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::\fI\%sink\fP::set_name(std::string  name) 
Sets the sink\(aqs name to the specified value. 
.UNINDENT
.INDENT 0.0
.TP
.B inline  void  xtr::\fI\%logger\fP::\fI\%sink\fP::set_level(\fI\%log_level_t\fP  l) 
Sets the log level of the sink to the specified level. 
.UNINDENT
.INDENT 0.0
.TP
.B inline  \fI\%log_level_t\fP  xtr::\fI\%logger\fP::\fI\%sink\fP::level()  const 
Returns the current log level. 
.UNINDENT
.INDENT 0.0
.TP
.B void  xtr::\fI\%logger\fP::\fI\%sink\fP::close() 
Closes the sink. After this function returns the sink is closed and \fI\%log()\fP functions may not be called on the sink. The sink may be re\-opened by calling \fI\%logger::register_sink\fP\&. 
.UNINDENT
.INDENT 0.0
.TP
.B inline  void  xtr::\fI\%logger\fP::\fI\%sink\fP::sync() 
Synchronizes all log calls previously made by this sink to back\-end storage.
.INDENT 7.0
.TP
.B Post
All entries in the sink\(aqs queue have been delivered to the back\-end, and the flush() and \fI\%sync()\fP functions associated with the back\-end have been called. For the default (disk) back\-end this means fflush(3) and fsync(2) (if available) have been called. 
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B template<auto  Format,  typename  Tags  =  void(),  typename  \&...Args> void  xtr::\fI\%logger\fP::\fI\%sink\fP::log(\fI\%Args\fP&&\&...  args)  noexcept((XTR_NOTHROW_INGESTIBLE(\fI\%Args\fP,  \fI\%args\fP)  &&  \&...)) 
Logs the given format string and arguments. This function is not intended to be used directly, instead one of the XTR_LOG macros should be used. It is provided for use in situations where use of a macro may be undesirable. 
.UNINDENT
.SH MISC
.INDENT 0.0
.TP
.B template<typename  T> inline  auto  xtr::nocopy(const  \fI\%T\fP  &arg) 
.UNINDENT
.INDENT 0.0
.TP
.B enum  xtr::log_level_t 
\fIValues:\fP
.INDENT 7.0
.TP
.B enumerator  none 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  fatal 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  error 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  warning 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  info 
.UNINDENT
.INDENT 7.0
.TP
.B enumerator  debug 
.UNINDENT
.UNINDENT
.SH AUTHOR
Chris E. Holloway
.SH COPYRIGHT
2021, Chris E. Holloway
.\" Generated by docutils manpage writer.
.
